#+TITLE: Python学习笔记
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: python

* 语言要点
#+HTML: <!--abstract-begin-->
Python对程序格式有较强的限定，如下所示：
- Python的注释符为 =#=
- Python行尾不需要加额外的字符以表示结束
  - 如果语句太长，可以对换行符转义，也就是在行尾加上 =\= 符号。
    如果括号或字符串没有配对，就没必要对换行符转义，
    因为Python知道此时一行语句没有结束。
- Python用相同缩进来表达同一语句块
  - 由于TAB的长度往往被修改，所以源代码中最好只有空格。
- Python源代码默认只接受ASCII字符集
  - 要使用其他字符集，需要加上编码声明，
    如 =# -*- coding: utf-8 -*-=
#+HTML: <!--abstract-end-->

** 数据与操作
*** 数据类型
- 数字类型包括整型、浮点型和复数型
- 序列类型包括字符串、元组、列表
- 集合、字典
- 空类型是指None对象
- 可调用类型，在类型中实现了 =__call__= 方法
- 布尔类型，语义比较广泛，如空字典、空集合都是False

- 变量无需声明，del可以解除一个变量的名字绑定
- 引用成员用点操作符(=.=)，引用元素用下标操作符(=[]=)，
  引用调用函数用函数符(=()=)。

*** 简单操作
- 比较有趣的是链式表达，如下面两个表达式等价。
#+BEGIN_SRC python
a < b <= c < d
a < b and b <= c and c < d
#+END_SRC
- 三元表达方式如下所示。
#+BEGIN_SRC python
returntrue if condition else returnfalse
#+END_SRC
- 所有序列都支持测试成员是否存在， =if item in seqs=

*** 列表操作
- 删除子序列可以用del操作符
#+BEGIN_SRC python
x = [1, 2, 3, 4, 5]
del x[1]                                # x = [1, 3, 4, 5]
del x[::2]                              # x = [3, 5]
#+END_SRC

- l.count(x) :: x出现次数
- l.index(x) :: x出现下标
- l.append(x) :: 在尾部加入x
- l.extend(x) :: 插入x中的所有元素，append则是将x当作一个元素插入
- l.insert(i, x) :: 在下标i处插入x
- l.remove(x) :: 删除x第一次出现，如果未出现则引发异常
- l.pop([i]) :: 删除下标为i的元素，如果未指定i，就删除最后一个元素，
     返回删除的元素，如果下标越界，引发异常
- l.reverse() :: 反转
- l.sort(cmp=cmp, key=None, reverse=False) :: 排序，
     key的意思是比较key(x)而不是比较x本身。
*** 集合操作
- s.copy() :: shallow copy
- s.difference(s1) :: s出现s1未出现
- s.intersection(s1) :: s和s1同时出现
- s.issubset(s1) :: s是s1的子集
- s.issuperset(s1) :: s1是s的子集
- s.symmetric_difference(s1) :: 只在s和s1其一出现
- s.union(s1) :: 在s或s1中出现
- s.add(x) :: 添加
- s.clear() :: 清除
- s.discard(x) :: 删除x，如果不存在也没关系
- s.pop() :: 随机弹出一个元素并返回
- s.remove(x) :: 如果未出现x会产生异常
*** 字典操作
- d.copy() :: shallow copy
- d.has_key(x) :: 测试是否有键x
- d.items()/d.iteritems() :: (key, value)对列表
- d.keys()/d.iterkeys() :: 键列表
- d.values()/d.itervalues() :: 值列表
- d.get(k[, x]) :: 这个函数非常有用，如果k存在就返回d[k]，
     否则返回x，如果未指定x就返回None
- d.clear() :: 清除
- d.update(d1) :: 效果上等价于：=for k in d1: d[k] = d1[k]=
- d.setdefault(k[, x]) :: 如果k存在就返回d[k]，
     否则将d[k]设置为x并返回
- d.pop(k[, x]) :: 弹出k，如果没有找到就返回x，
     注意如果没有指定x又没有找到k就会引发异常
- d.popitem() :: 随机弹出一个元素

** 流程控制
*** 分支语句
#+BEGIN_SRC python
if condiiton:
    statements
elif condition:
    statements
else:
    statements
#+END_SRC

要判断一个变量是否为真，直接的方式是 =if x= ，
请不要使用如下的一些形式：
#+BEGIN_SRC python
if x is True
if x == True
if bool(x)
#+END_SRC

*** 循环语句
#+BEGIN_SRC python
while condition:
    statements
#+END_SRC

#+BEGIN_SRC python
for item in iterable:
    statements
#+END_SRC

列表表达式(list comprehensions)是Python特有一个语法。
#+BEGIN_SRC python
[expression for item in iterable clauses]
#+END_SRC

例如：
#+BEGIN_SRC python
[x + 1 for x in range(10)]
[x + 1 for x in range(10) if x % 2]
[x + y for x in range(10) for y in range(10)]
#+END_SRC
*** 跳转语句
| break    | 退出循环       |
| continue | 进入下一轮循环 |

** 函数
#+BEGIN_SRC python
def functionname(parameters):
    statements
#+END_SRC
*** 属性
#+BEGIN_SRC python :results output :exports both
def sum_args(*nums):
    '''accept arbitrary numerical arguments and return their sum'''
    return sum(nums)

print sum_args.__name__
print sum_args.__doc__
print sum_args(1, 2, 3)
#+END_SRC

#+RESULTS:
: sum_args
: accept arbitrary numerical arguments and return their sum
: 6

*** 名称空间
函数默认将变量绑定到局部名称空间，要使用全局的名字，
就需要在函数中作如下声明。
#+BEGIN_SRC python
global indentifiers
#+END_SRC

*** 匿名函数
#+BEGIN_SRC python
lambda parameters: expression
#+END_SRC

*** 生成器
#+BEGIN_SRC python
yield expression
#+END_SRC

#+BEGIN_SRC python :results output :exports both
def updown(n):
    for x in range(n):
        yield x
    for x in range(n - 1, -1, -1):
        yield x
for i in updown(10):
    print i,
#+END_SRC

#+RESULTS:
: 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0

** 类与继承
*** 基本概念
Python2支持经典模型和新风格，Python3只支持新风格，
所以最好是只使用单根继承。
类型存储静态字段和方法，实例只存储数据字段，也称为attribute。
访问对象成员时，按照如下顺序查找：
=instance.__dict__=、=class.__dict__=、=baseclass.__dict__=

注意不要和名字查找混淆，名字查找采用 =LEGB= 顺序在不同的作用域查找：
- locals :: 函数内部名字空间，形参和局部变量
- enclosing :: 嵌套函数的外部函数
- globals :: 函数所在模块名字空间
- __builtins__ :: 内置模块名称空间

私有字段以双下划线开头，会被重命名，一般建议单下划线，提示即可。

property由getter、setter、deleter几个方法构成，看示例代码。
#+BEGIN_SRC python :exports both :results output
class Example(object):
    @property
    def name(self): return self.__name

    @name.setter
    def name(self, val): self.__name = val

    @name.deleter
    def name(self): del self.__name

e = Example()
e.name = "example"
print e.__dict__, e.name
del e.name
#+END_SRC
property的访问优先级高于同名字段，在翻译上attribute和property都叫属性，
但是attribute是更通用的概念，包括字段或property，
而property是提供了getter/setter的特殊attribute，所以名字查找也是先找特殊的。
*** 类的方法
要实现类的方法，需要添加装饰器修饰：
#+BEGIN_SRC python :exports both :results output
class Example(obejct):
    @staticmethod
    def static_print(os):
        print os
#+END_SRC

特殊方法：
- __new__ :: 创建对象实例
- __init__ :: 初始化对象状态
- __del__ :: 对象回收前调用

Python提供了两个函数来判定类型关系：
- issubclass(a, base) :: 判断a是否是base的继承
- isinstance(a, class) :: 判断a是否是class的实例

多重继承MRO(method resolution order)：从下到上，从左到右。
#+BEGIN_SRC python :exports both :results output
class A(object):
    def print_a(self):
        print "a:a"
class B(object):
    def print_a(self):
        print "b:a"
    def print_b(self):
        print "b:b"

class C(A, B):
    def print_c(self):
        base = super(C, self)
        base.print_a()
        base.print_b()
C().print_c()
#+END_SRC

#+RESULTS:
: a:a
: b:b

Python也支持抽象类，只需要添加修饰即可，
派生类必须实现所有抽象函数/属性才能实例化：
#+BEGIN_SRC python
from abc import ABCMeta, abstractmethod, abstractproperty
class AbsExample(object):
    __metaclass__ = ABCMeta
    @abstractmethod
    def print_id(self):
        pass

    name = abstractproperty()

class Example(AbsExample):
    def print_id(self):
        print "id"
    name = property(lambda s: s._name,
                    lambda s, v: setattr(s, "_name", v))

e = Example()
#+END_SRC

Python还有一个特性叫开放类，可以在运行期增加/删除对象成员。
#+BEGIN_SRC python :exports both :results output
def print_id(self):
    print self.id

def print_class_id(cls):
    print "class: ", cls

def print_static():
    print "static"

class User(object):
    def __init__(self):
        self.id = "self id"

User.print_id = print_id
User.print_class_id = classmethod(print_class_id)
User.print_static = staticmethod(print_static)
u = User()
u.print_id()
User.print_class_id()
User.print_static()
#+END_SRC

#+RESULTS:
: self id
: class:  <class '__main__.User'>
: static

修改字段要用指定函数：
- setattr(obj, "name", value) :: =u.name = value=
- hasattr(obj, "name") :: =obj.__dict__["name"]=
- getattr(obj, "name", None) :: 如果未找到返回None
- delattr(obj, "name") :: =del obj.__dict__["name"]=

索引操作符 =[]= 也可以重载，
自定义 =__setitem__=、=__getitem__= 和 =__delitem__= 即可。
函数对象/仿函数通过定义 =__call__= 来重载。

- __getattr__ :: 访问不存在的成员
- __setattr__ :: 对成员赋值
- __delattr__ :: 删除成员
- __getattribute__ :: 访问任何存在或不存在的成员，包括 =__dict__=
在定义这些函数的时候，在里面不能调用 =setattr=、=getattr= 等函数，
会造成死循环，因此只能直接访问 =__dict__=。
而 =__getattribute__= 更狠，会拦截 =__dict__=，
所以它唯一能调用的就是基类的 =__getattribute__=。

* 语法陷阱
** 兼容性问题
兼容性问题主要是指Python2和Python3的兼容性。
*** 输入和输出

在python2中print是一个表达式，在python3中print是一个函数，
也就是说python2程序员写的print代码在python3下都不能运行。

在python2中的input函数会计算用户的输入，要防止计算就必须用raw_input，
而python3中将raw_input删除了，而input的含义等同于python2中的raw_input。

这些更改看上去更美好了，但是总感觉那么忧伤。

*** dict.items
在python2中字典有两个迭代函数。
- items(...) ::
     D.items() -> list of D's (key, value) pairs, as 2-tuples
- iteritems(...) ::
     D.iteritems() -> an iterator over the (key, value) items of D
很显然python2的程序员为了空间效率都会去调用 =iteritems()=，
但奇葩的python3将其删除了，只保留了items()，含义如下：
- items(...) ::
     D.items() -> a set-like object providing a view on D's items

** 奇怪的语法
*** 单元素元组
要定义单个元素的元组，必须加上一个逗号，否则就成了单个整数。
#+BEGIN_SRC sh
a = (41,)
#+END_SRC

这种丑陋的写法其实无可厚非，毕竟你为什么要创建单个元素的元组呢。
*** 循环分支
下面语句的else表示完整遍历了循环，无论怎样，看上去很怪。
从形式上看，没有执行循环去访问else更加合理。
#+BEGIN_SRC python :exports both :results output
while 0:
    pass
else:
    print "over all"
#+END_SRC

#+RESULTS:
: over all

** 特殊函数
*** 慎用 =__del__=
文章 [[http://www.708luo.com/posts/2015/04/python-del-method/][慎用python的__del__方法]] 比较详细分析了这个缺陷。
=__del__= 相当于C语言中的析构函数，但是问题是它不一定被调用。
也就是说如果你实现了 =__del__= 方法就不能出现循环引用，
否则垃圾回收器将因为不知道释放顺序而放弃释放。
下面是一个示例。

#+BEGIN_SRC python :exports both :results output
class A(object):
    def __init__(self, parent):
        print "A init"
        self.parent = parent

    def __del__(self):
        print "A del"

class B(object):
    def __init__(self):
        print "B init"
        self.child = A(self)

    def __del__(self):
        print "B del"

b = B()
#+END_SRC

#+RESULTS:
: B init
: A init

就凭这一点，程序员应该不要去实现 =__del__= 函数，
当然这个问题应该归罪于Python本身，既然有这么严重的问题，
就不应该给用户提供接口。

* 常用模块
** 基本模块
- 时间和日期模块
  - [[http://www.wklken.me/posts/2015/03/03/python-base-datetime.html][PYTHON-基础-时间日期处理小结]]
  - [[https://docs.python.org/2/library/datetime.html][8.1. datetime — Basic date and time types]]
- 绘图模块
  - [[http://www.labri.fr/perso/nrougier/teaching/matplotlib/][Matplotlib tutorial]]

** subprocess
subprocess模块位于Python标准库的[[https://docs.python.org/2/library/ipc.html][Interprocess Communication and Networking]]部分，
subprocess模块非常强大，可以创建新的进程，连接到其他管道，获取返回值等，
官方希望用这个模块替代 os.system、os.spawn*、os.popen*、popen2.*和commands.*
等模块/函数。至于为什么要使用这个模块可以参考[[https://www.python.org/dev/peps/pep-0324/][PEP 324]]的说明。
要替换以前的函数也不难，比方os.system()可以用subporcess.call()来替代。

*** Popen类
subprocess中定义了一个Popen类，如下所示。
#+BEGIN_SRC python
class Popen(args, bufsize=0, executable=None,
            stdin=None, stdout=None, stderr=None,
            preexec_fn=None, close_fds=False, shell=False,
            cwd=None, env=None, universal_newlines=False,
            startupinfo=None, creationflags=0):
#+END_SRC
- args :: 字符串或程序参数序列，当指定shell=True时，因为所有参数都是传递给shell，
     所以实际上并不需要写成序列形式，可以所有参数直接写到一个字符串中。
- bufsize :: 默认不缓冲，如果指定为负数，就使用系统默认缓冲大小。
- stdin :: 可以指定为PIPE、文件描述符、文件对象和None。
- close_fds :: 执行子进程时将关闭所有文件描述符，标准输入输出例外。
- cwd :: 指定当前目录。
- env :: 为子进程定义环境变量。


Popen类中常用方法如下：
- poll() :: 检查进程是否结束，返回返回值
- wait() :: 等待进程结束，返回返回值
- communicate(input=None) :: 返回一个元组，(stdout, stderr)

Popen类中常用变量如下
- stdin :: 如果参数设置为PIPE，该属性就是一个文件对象
- pid :: 进程号
- returncode :: 返回值

*** subprocess
常用方法：
#+BEGIN_SRC python
subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)
subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None,
                      shell=False)
subprocess.check_output(args, *, stdin=None, stderr=None, shell=False,
                        universal_newlines=False)
#+END_SRC
注意，最好不要将stdout/stderr设置为PIPE，要设置的话请使用Popen类，
因为将stdout/stderr设置为PIPE有死锁的风险。
- check_call :: 正常返回0，当子进程返回值不为0的时候产生CalledProcessError。
- check_output :: 返回输出字符串，当子进程返回值不为0时产生CalledProcessError。

常用变量：
#+BEGIN_SRC python
subprocess.PIPE
subprocess.STDOUT
exception subprocess.CalledProcessError
#+END_SRC

*** 替代方法
推荐参考[[https://docs.python.org/2/library/subprocess.html#replacing-older-functions-with-the-subprocess-module][17.1.4. Replacing Older Functions with the subprocess Module]]这部分内容。

#+BEGIN_SRC python
# ls -l
output = Popen(["ls", "-l"], stdout=PIPE).communicate()[0]

# dmesg | grep hda
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
output = p2.communicate()[0]
#+END_SRC

#+BEGIN_SRC python
# ls -l
p = Popen("ls -l", shell=True)
stat = os.waitpid(p.pid, 0)
#+END_SRC
更好的写法是这样的。
#+BEGIN_SRC python
try:
    retcode = call("ls -l", shell=True)
    if retcode < 0:
        print >>sys.stderr, "Child was terminated by signal", -retcode
    else:
        print >>sys.stderr, "Child returned", retcode
except OSError, e:
    print >>sys.stderr, "Execution failed:", e
#+END_SRC

* 单元测试
首先要理解测试用例的概念。
- 自动运行，不需要人工输入
- 自动确定结果，不用人为判断结果的正确性
- 独立运行，每个用例可以单独运行

#+BEGIN_SRC python
import unittest

class KnownValues(unittest.TestCase):
    """to_roman should give known result with known input"""
    known_values = ((1, 'I'),
                    (2, 'II'),
                    ...,
                    (3999, 'MMMCMXCIX'))
    def test_to_roman_known_values(self):
        for integer, numeral in self.known_values:
            result = roman1.to_roman(integer)
            self.assertEqual(numeral, result)


if __name__ == '__main__':
    unittest.main()
#+END_SRC
- assertEqual :: 当发现错误时，会抛出异常，并且测试不通过。
- unittest.main() :: 对每一个测试用例，unittest模块都会打印其文档字符串。

除了要测试正常用例，还需要输入非正常用例，让其能够在预料的情况下工作。
错误用例的写法如下所示，当然也可以将用例都写入到一个class，
这里分开主要是便于分类。
#+BEGIN_SRC python
class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
#+END_SRC

接下来可以看看基本代码。
#+BEGIN_SRC python
class OutOfRangeError(ValueError):
    pass

class NotIntegerError(ValueError):
    pass

def to_roman(n):
    '''convert integer to Roman numeral'''
    if not isinstance(n, int):
        raise NotIntegerError('non-integers can not be converted')
    if not (0 < n < 4000):
        raise OutOfRangeError('number out of range (must be less than 4000)')

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result
#+END_SRC

当然在ToRomanBadInput类中，还可以添加很多测试，比如值过小，负数，类型错误等等。

如果我们写好了to_roman()函数，要测试from_roman()就非常容易了。
利用如下恒等式可以快速编写测试用例。
#+BEGIN_SRC python
n = from_roman(to_roman(n))
#+END_SRC

编写from_roman()是很困难的，因为识别非法字符串就很很困难。
- 字符可相加也可能相减：I->1、II->2、III->3、VI->6、VII->7、VIII->8、IX->9等等
- IXCM可以连续重复最多三次
- VL不能连续重复
#+BEGIN_SRC python
roman_numeral_pattern = re.compile('''
^                # beginning of string
M{0,3}           # thousands - 0 to 3 Ms
(CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
                 # or 500-800 (D, followed by 0 to 3 Cs)
(XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
                 # or 50-80 (L, followed by 0 to 3 Xs)
(IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
                 # or 5-8 (V, followed by 0 to 3 Is)
$                # end of string
''', re.VERBOSE)

def from_roman(s):
    """convert Roman numeral to integer"""
    if not roman_numeral_pattern.search(s):
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
#+END_SRC

* 参考资料
- [[http://www.diveintopython3.net/][Dive Into Python 3]]
- [[http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html][PyCoder’s Weekly 中文翻译]]
- [[https://docs.python.org/2/library/subprocess.html][17.1. subprocess — Subprocess management]]
- [[https://docs.python.org/3/library/argparse.html][Python3: 16.4. argparse — Parser for command-line options, arguments and sub-commands]]
- [[https://docs.python.org/2/howto/argparse.html][Python2: Argparse Tutorial]]
- [[http://pymotw.com/2/argparse/][Python2: argparse – Command line option and argument parsing]]
- [[http://youngsterxyf.github.io/2013/03/30/argparse/][Python2: argparse – Command line option and argument parsing（中文）]]
