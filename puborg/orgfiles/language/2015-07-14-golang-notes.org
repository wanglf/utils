#+TITLE: Go语言笔记
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: go

* 语言特性综述
#+HTML: <!--abstract-begin-->

go语言相对于C/C++做了诸多改进。
1. 语言强制规定代码规范，如大小写、括号位置
2. 错误处理采用多返回值和 =defer= 统一格式
3. 没有重载，没有继承，没有虚函数，没有构造函数和析构函数
4. 提供一种非侵入性接口，实现一个接口无需继承指定接口
5. 支持匿名函数与闭包
6. 自动垃圾回收，让程序员不再为了内存管理问题而通宵达旦
7. 新增常用数据类型，如map、slice

#+HTML: <!--abstract-end-->

* 基本元素
** 类型

变量名前置于类型名，支持多变量定义及赋值。使用 ~:=~ 定义变量可以自动推断类型。
多变量赋值的要点是先计算后赋值。
变量的关键字为 =var=，常量的关键字为 =const=。枚举不使用 =enum= 而是采用 =const=
关键字，引入 =iota= 表示自动计数。个人觉得 =iota= 容易出现问题，
只在最基本的情况下使用即可。

引入各种固定长度类型，有助于脱离平台限制。要注意不支持隐式类型转换，
即便是整型向布尔转换也不行。

其中 =slice=、=map=、=channel= 是引用类型，因为其内部结构复杂，需要管理内存和属性。

字符串被设计为不可变对象，也就是不能修改字符，字符串末尾没有空字符。
字符串支持切片操作。
用 =``= 定义的字符串不对转义字符转义，支持跨行。
要修改字符串可以转换为 =[]rune= 或 =[]byte=，转换会导致复制内存，
记住 =rune= 就是 =int32=。遍历字符串用 =range= 完成，要按字节遍历可以直接用下标访问。

指针有解引用和成员操作符，注意成员操作符是 =.=，而 =->= 操作符不存在，
在语言层面已经实现了自动区分功能。不支持指针的算术运算。
比较特别的是返回局部变量的指针是安全的。

关键字 =type= 用于定义新类型，和 =typedef= 相似。
** 表达式
不支持运算符重载，另外注意 =++= 和 =--= 是语句，而不是表达式，
不能在其它表达式中使用。

按位取反运算采用 =^= 算符，而 =~= 算符不再使用。

对if语句添加了初始化语句支持，没有 =?:= 操作符。
#+BEGIN_SRC go
if n := "abc"; x > 0 {
	println(n[2])
} else if x < 0 {
	println(n[1])
} else {
	println(n[0])
}
#+END_SRC

对for语句做了大量重载工作，将原来属于while语句的写法都移植到for语句中了。
利用多元赋值可以减少循环计算量。
#+BEGIN_SRC go
for i, n := 0, length(s); i < n; i++ {
	println(i, s[i])
}
#+END_SRC

迭代语句range对不同的序列返回不同，如下表：
| string      | (i, s[i])     |
| array/slice | (i, a[i])     |
| map         | (key, m[key]) |
| channel     | e             |
另外要注意的是range所返回的对象是复制对象，而不是原生对象。
当使用引用类型时，底层数据不会被复制。

分支语句switch不再需要写break了，要继续则要显示注明fallthrough。
省略元素判别之后就可以当作 =if...else if...= 语句。

跳转语句break/continue支持带标签形式。
** 函数
不支持嵌套、重载和默认参数。支持匿名函数和闭包。

变参本质上是slice，只能放于最后。使用slice作为变参时，需要展开为 =s...=。

多返回值只能用多变量接，不能用容器对象接收，但是可以直接传递给函数参数。
对于命名返回参数，如果被局部变量遮蔽，就需要显式返回。
#+BEGIN_SRC go
func add(x, y int) (z int) {
	{
		var z = x + y
		return			// ERROR: z is shadowed during return
		return z
	}
}
#+END_SRC

命名返回参数支持 =defer= 延迟通过闭包修改。
#+BEGIN_SRC go
func add(x, y int) (z int) {
	defer func() {
		z += 100
	}()
	z = x + y
	return
}
#+END_SRC

匿名函数可以在channel中传送。
#+BEGIN_SRC go
fc := make(chan func() string, 2)
fc <- func() string { return "Hello, World!" }
println((<-fc)())
#+END_SRC

延迟调用主要负责释放资源和错误处理。不要滥用defer功能，
滥用defer功能容易引发性能问题。
多个defer采用FILO顺序执行。

用panic抛出错误，用recover修复错误。对recover的调用有非常严格的限制，
必须在 =defer= 函数内直接调用才会终止错误，其它地方调用仅返回nil。

* 结构体
** 数据
数组被设计为数值类型，赋值和参数传递会复制整个数组。
指针数组 =[n]*T= 和数组指针 =*[n]T= 表达上看星号位置。
因为数组是值传递，所以实际上很少会用到，大多情况都使用slice。

slice是语言层面提供的主打类型：
#+BEGIN_SRC go
struct Slice
{
	byte*    array;      // actual data
	uintgo   len;        // number of elements
	uintgo   cap;        // allocated number of elements
};
#+END_SRC
对数组切片会返回slice，比较奇葩的是为了节省内存，居然不会复制。
#+BEGIN_SRC go
data := [...]int{0, 1, 2, 3, 4, 5, 6}
slice := data[1:4:5]			// [beg:end:cap]
#+END_SRC
不止可以对数组切片，也可以对slice切片，都不会复制。
- append(s, x...) :: 用于向slice尾部添加数据，超出cap就会重新分配并复制。
- copy(dst, src) :: 以长度小的为准

map是基于哈希表的引用类型，支持index、delete操作。
索引取回的是复制品，故对齐成员修改没有意义，只能是用一个新的值去替换。
迭代时可以删除，但是不要新增。

结构体顺序初始化必须包括全部字段，结构体支持匿名字段，
但是程序员不应该使用这个语法糖。
对于面向对象三大特征封装、继承和多态，语言层面只支持封装。
** 方法
方法只不过多了一个接收对象，可以理解为函数的第一个隐式参数。
对于方法的查找，要注意不支持多级指针查找，
也就是说想通过多级指针调用方法，就必须显式声明接收对象为多级指针。

通过匿名字段可以获得和继承类似的复用能力，利用编译器查找次序可以实现重写。
但是正如前面所说，这不过是一个语法糖，不应该在项目中使用这种方法。

对方法调用有两种形式：
#+BEGIN_SRC go
instance.method(args...)		// method value
<type>.func(instance, args...)		// method expression
#+END_SRC
method value会复制接收对象：
#+BEGIN_SRC go
func main() {
	u := User{1, "Tom"}
	mValue := u.Test           // copy receiver
	u.id, u.name = 2, "Jack"
	u.Test()
	mValue()
}
#+END_SRC
** 接口
接口本质上就是方法的集合，只要一个类实现了接口中的所有函数，
那么就是提供了该接口。
如下所示，所有动物都可以定一个Speak()接口。
#+BEGIN_SRC go
type Animal interface {
	Speak() string
}
func (c Cat) Speak() string {
	return "Meow!"
}
func (j JavaProgrammer) Speak() string {
	return "Design patterns!"
}
#+END_SRC

* 高级特性
** 并发
在语言层面提供了 =goroutine=，单个进程可以执行成千上万的并发任务，
提供 =channel= 来通讯。
=channel= 在内部实现提供了同步机制，能确保并发安全，
默认采用同步模式，接收和发送必须配对，否则一直阻塞。

#+BEGIN_SRC go
func main() {
	data := make(chan int)           // 数据交换队列
	exit := make(chan bool)          // 退出通知
	go func() {
		for d := range data {    // 从队列迭代接收数据，直到 close
			fmt.Println(d)
		}
		fmt.Println("recv over.")
		exit <- true             // 发出退出通知
	}()
	data <- 1                        // 发送数据
	data <- 2
	data <- 3
	close(data)                      // 关闭队列
	fmt.Println("send over.")
	<-exit                           // 等待退出通知
}
#+END_SRC

异步方式通过缓冲区来决定是否阻塞，利用缓冲区来提供效率，
另一方面应该考虑指针来规避大数据复制。

对已关闭的channel发送数据会引发panic，从已关闭channel接收数据会返回零值。
对于nil channel，收发都会阻塞。

#+BEGIN_SRC go
c := make(chan int, 3)
var send chan<- int = c			// send only
var recv <-chan int = c			// recv only
send <- 1
<-recv
#+END_SRC

多通道选择用select完成：
#+BEGIN_SRC go
for {
	select {
	case v, ok = <-a: s = "a"
	case v, ok = <-b: s = "b"
	}
	if ok {
		fmt.Println(s, v)
	} else {
		os.Exit(0)
	}
}

for i := 0; i < 5; i++ {
	select {
	case a <- i:
	case b <- i:
	}
}
#+END_SRC
** 包
导入包的几种写法：
#+BEGIN_SRC go
import     "sample/test"      // test.A
import  M  "sample/test"      // M.A
import  .  "sample/test"      // A
import  _  "sample/test"      // 仅执行初始化函数
#+END_SRC

* 学习资料
1. 快速学习基本用法，推荐两本书。
   - http://www.golang-book.com/，
     PDF版：https://www.golang-book.com/assets/pdf/gobook.pdf。
   - http://www.miek.nl/downloads/Go/Learning-Go-latest.pdf，
     中文版：http://mikespook.com/learning-go/。

   可以同步参考：https://gobyexample.com/。
   如果精通C语言的话，这部分内容大约可以在一个星期内完成，
   否则可能需要一个月以上的时间。
   学习完这两部份内容就可以用golang解决基本问题了。

2. 全面学习基础知识，推荐两本书。
   - [[http://www.pdfiles.com/pdf/files/English/Desktop_Apps_Programming/The_GO_Programming_Language.pdf][The Go Programming Language]]，这本书有中文版，即[[http://pan.baidu.com/share/link?shareid%3D803045079&uk%3D2047156413][Go语言编程]]。
   - [[http://ptgmedia.pearsoncmg.com/images/9780321774637/samplepages/0321774639.pdf][Programming in Go]]
   - [[https://github.com/astaxie/build-web-application-with-golang][build a web with golang]]

   由于目前go语言还处于成长期，所以还没有出现比较经典的著作，
   学完这些基本知识以后就可以在实际使用中进一步去学习。
#+HTML: <!--abstract-end-->

3. 补充资料
   - [[http://blog.csdn.net/wonderfogo/article/details/7096176][Go语言资料收集]]/[[https://github.com/wonderfo/wonderfogo/wiki][Go语言资料收集]]
   - [[http://jan.newmarch.name/go/all.pdf][Network programming with Go]]

