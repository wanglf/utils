#+TITLE: 基本排序算法
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: sort algorithm

* 简单排序
** 冒包排序
#+HTML: <!--abstract-begin-->
冒泡排序第一趟找出最小的元素，第二趟找出剩下最小的元素，依次类推。
#+BEGIN_SRC python :results output :exports both
def bubble_sort(seq):
    n = len(seq)
    if n < 2:
        return
    for i in range(n - 1):
        for j in range(n - 1, i, -1):
            if seq[i] > seq[j]:
                seq[i], seq[j] = seq[j], seq[i]
    print seq
bubble_sort([8, 94, 45, 63, 7, 7, 31])
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]
#+HTML: <!--abstract-end-->

** 插入排序
将当前元素插入到前面已经排序的合适位置，
在算法设计的时候可以将前面比当前大的元素依次后移，
再把当前元素插入正确的空位中。
#+BEGIN_CENTER
#+CAPTION: 插入排序示意图
file:fig/sort/insert-sort.png
#+END_CENTER

#+BEGIN_SRC python :results output :exports both
def insert_sort(seq):
    n = len(seq)
    if n < 2:
        return
    for i in range(n):
        cur, j = seq[i], i-1
        while j >= 0:
            if cur < seq[j]:
                seq[j+1] = seq[j]
            else:
                break
            j -= 1
        seq[j+1] = cur
    print seq
insert_sort([8, 94, 45, 63, 7, 7, 31])
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]

* 经典排序
** 归并排序
归并排序需要两步工作，第一步是划分未排序，第二步是合并已排序。
#+BEGIN_SRC python :results output :exports both
def merge_sorted(seq, start, mid, end):
    a, b, i, j = seq[start:mid], seq[mid:end], 0, 0
    for k in range(start, end):
        if (i == mid - start) or ((j < end - mid) and a[i] > b[j]):
            seq[k] = b[j]
            j += 1
        else:
            seq[k] = a[i]
            i += 1

def do_merge_sort(seq, start, end):
    if end - start < 2:
        return
    mid = (start + end) / 2
    do_merge_sort(seq, start, mid)
    do_merge_sort(seq, mid, end)
    merge_sorted(seq, start, mid, end)

def merge_sort(seq):
    do_merge_sort(seq, 0, len(seq))
    print seq

merge_sort([8, 94, 45, 63, 7, 7, 31])
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]

** 堆排序
堆排序是设计非常巧妙的排序，堆是一个数组，
展开为树结构之后保证上一层元素比下一层元素小。
#+BEGIN_CENTER
#+CAPTION: 堆数组
file:fig/sort/heap-arrary.png
#+END_CENTER

堆排序最巧妙的函数是 =max_heapify()=，需要注意这是一个递归函数，
它将一个不合法的值插入到根节点，前提是左右子堆都是合法的堆，
通过递归交换，把不合法的值传递到合法的位置。
这个函数被两次利用，建堆的时候用一次，排序的时候又用一次，
这其中的巧妙需要细细体会。

#+BEGIN_SRC python :results output :exports both
def left(i):
    return 2*i + 1
def right(i):
    return 2*i + 2

def max_heapify(A, i, size):
    maxi, l, r = i, left(i), right(i)
    if l < size and A[l] > A[maxi]:
        maxi = l
    if r < size and A[r] > A[maxi]:
        maxi = r
    if maxi != i:
        A[i], A[maxi] = A[maxi], A[i]
        max_heapify(A, maxi, size)

def build_max_heap(A, size):
    for i in range(size/2, -1, -1):
        max_heapify(A, i, size)         # O(lgn)

def heap_sort(A):
    size = len(A)
    if size < 2:
        return
    build_max_heap(A, size)             # O(nlgn)
    for i in range(size - 1, 0, -1):
        A[i], A[0] = A[0], A[i]
        max_heapify(A, 0, i)
    print A

heap_sort([8, 94, 45, 63, 7, 7, 31])
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]

** 快速排序
快速排序的思路还是比较清晰的，将序列分成两半，一半比指定值小，
一半比指定值大，递归分割完成之后就排好序了。

快速排序有很多中不同的分割方式，比较著名的是HOARE分割算法，
在算法导论中给出的Hoare分割和简单分割有细微不同的地方，
为了显示其差异，读者可以仔细体会下面代码中 =hoare_partition()=
和 =hoare_partition_pop()= 的区别。

#+BEGIN_SRC python :results output :exports both
def simple_partition(A, start, end):
    if end - start < 2:
        return start, start+1
    i, x = start, A[end - 1]
    for j in range(start, end - 1):
        if A[j] < x:
            A[i], A[j] = A[j], A[i]
            i += 1
    A[i], A[end-1] = A[end-1], A[i]
    return i, i+1

def do_quick_sort(A, start, end, pfunc):
    if end - start < 2:
        return
    prev, next = pfunc(A, start, end)
    do_quick_sort(A, start, prev, pfunc)
    do_quick_sort(A, next, end, pfunc)

def quick_sort(A, pfunc=simple_partition):
    do_quick_sort(A, 0, len(A), pfunc)
    print A

def hoare_partition(A, start, end):
    if end - start < 2:
        return start, start
    x, i, j = A[start], start, end-1
    while i < j:
        while i < j and A[j] >= x:
            j -= 1
        while i < j and A[i] < x:
            i += 1
        if i < j:
            A[i], A[j] = A[j], A[i]
    return j+1, j+1

def hoare_partition_pop(A, start, end):
    if end - start < 2:
        return start, start+1
    x, i, j = A[start], start, end - 1
    while i < j:
        while i < j and A[j] > x:
            j -= 1
        while i < j and A[i] <= x:
            i += 1
        if i < j:
            A[i], A[j] = A[j], A[i]
    A[start], A[j] = A[j], A[start]
    return j, j+1

quick_sort([8, 94, 45, 63, 7, 7, 31])
quick_sort([8, 94, 45, 63, 7, 7, 31], hoare_partition)
quick_sort([8, 94, 45, 63, 7, 7, 31], hoare_partition_pop)
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]
: [7, 7, 8, 31, 45, 63, 94]
: [7, 7, 8, 31, 45, 63, 94]


* 特殊排序
** 计数排序
计数排序的思路是非常简单的，如果我们知道小于或等于当前元素的个数，
那么就可以直接将当前元素放到输出序列的对应位置。

这种排序算法需要限制输入序列值的范围，并且只能处理整数。

#+BEGIN_SRC python :results output :exports both
def count_sort(A):
    minx = min(A)
    A = [x-minx for x in A]
    n, k = len(A), max(A) + 1
    B, C = [0] * n, [0] * k
    for i in range(n):
        C[A[i]] = C[A[i]] + 1           # C[i] == counts(val == i)
    for i in range(1, k):
        C[i] += C[i-1]                  # C[i] == counts(val <= i)
    for i in range(n - 1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
    A = [x+minx for x in B]
    print A

count_sort([8, 94, 45, 63, 7, 7, 31])
#+END_SRC

#+RESULTS:
: [7, 7, 8, 31, 45, 63, 94]
